# Cursor-Agent Rules

- Before starting the server, kill all running processes, then start the server.
- Use pnpm to install dependencies, and use pnpm run dev to start the server.
- After completing each feature, use mcp chrome-devtools to test the functionality and page integrity.
- use docker-compose up -d to start the database.
- Refer to the latest documentation for development. Use mcp context7 to get the latest documentation.

# B2C Business Platform - Essential Rules

## Tech Stack
- **Framework**: Next.js 15 + TypeScript 5 (strict mode)
- **Database**: PostgreSQL + Prisma ORM
- **Auth**: NextAuth.js v4 (ADMIN/USER roles)
- **Payment**: Stripe integration
- **UI**: Tailwind CSS + shadcn/ui
- **Forms**: React Hook Form + Zod validation

## Key Guidelines
- Use server components by default, client components only when needed ('use client')
- Use absolute imports with @ alias (@/components, @/lib, etc.)
- Implement proper error handling with try-catch blocks
- Use proper HTTP status codes and consistent API response format
- Follow Next.js 15 App Router conventions
- Validate all inputs with Zod schemas

## File Structure
```
src/
├── app/          # Next.js App Router (pages & API routes)
├── components/   # React components (ui/, admin/, forms/)
├── hooks/        # Custom React hooks
├── lib/          # Utilities (auth, db, stripe, etc.)
└── types/        # TypeScript definitions
```

## Essential Patterns

### API Route
```typescript
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const data = await prisma.model.findMany();
    return NextResponse.json({ success: true, data });
  } catch (error) {
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```

### Server Component
```typescript
interface PageProps {
  params: Promise<{ id: string }>;
}

export default async function Page({ params }: PageProps) {
  const { id } = await params;
  const data = await fetchData(id);
  if (!data) notFound();
  return <div>{/* JSX */}</div>;
}
```

### Form Component
```typescript
'use client';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

const schema = z.object({ /* fields */ });
type FormData = z.infer<typeof schema>;

export default function FormComponent() {
  const form = useForm<FormData>({ resolver: zodResolver(schema) });
  const onSubmit = async (data: FormData) => { /* handle */ };
  return <form onSubmit={form.handleSubmit(onSubmit)}>{/* fields */}</form>;
}
```

## Security & Performance
- Use getServerSession for auth checks
- Validate user permissions on client and server
- Use proper TypeScript types (avoid `any`)
- Implement responsive design (mobile-first)
- Use React.memo() for optimization when needed
- Handle loading/error states properly

## Business Context
B2C platform for consumer products with multi-language support, payment processing, product catalog, admin dashboard, and customer support system.
